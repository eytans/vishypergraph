{"version":3,"sources":["HyperGraph.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["ID","id","label","Object","classCallCheck","this","createClass","key","value","toString","Node","literal","shape","arguments","length","undefined","HyperEdge","type","sources","hasTarget","optionsDefault","layout","hierarchical","edges","color","nodes","margin","HyperGraph","_Component","props","_this","possibleConstructorReturn","getPrototypeOf","call","options","events","select","event","handleResize","console","log","forceUpdate","_optionsDefault$props","objectSpread","objectWithoutProperties","inherits","window","addEventListener","removeEventListener","_this2","maxId","Math","max","apply","toConsumableArray","map","index","array","toVisNode","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_loop","edge","newNode","push","concat","to","from","_iterator","Symbol","iterator","next","done","err","return","graph","react_default","a","createElement","vis_react_default","Component","App","textRef","React","createRef","state","text","isPattern","parser","generate","tracer","Tracer","tree","parse","e","getBacktraceString","current","parseText","getEdges","parseEdge","Map","flatMap","f","setState","Array","values","Container","style","height","minHeight","Row","Col","Button","onClick","handleClick","bind","Form","Control","ref","width","placeholder","HyperGraph_HyperGraph","graphkey","keys","find","element","toLowerCase","includes","Error","isArray","hyperTermId","hyperTermIdentifier","eType","extractIdentifier","target","extractId","Boolean","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.68cd4c95.chunk.js","sourcesContent":["import React, { Component } from 'react'\r\nimport Graph from 'vis-react'\r\n\r\ninterface VisNode {\r\n    id: number;\r\n    label: string;\r\n    shape?: string;\r\n}\r\n\r\ninterface VisEdge {\r\n    from: number;\r\n    to: number;\r\n}\r\n\r\nexport class ID {\r\n    id: number;\r\n    label?: string;\r\n\r\n    constructor(id: number, label?: string) {\r\n        this.id = id;\r\n        this.label = label;\r\n    }\r\n\r\n    toString() {\r\n        if (this.label == null) {\r\n            return this.id.toString();\r\n        }\r\n        return this.label;\r\n    }\r\n}\r\n\r\nexport class Node {\r\n    id: ID;\r\n    literal?: string;\r\n    shape?: string;\r\n\r\n    constructor(id: ID, literal?: string, shape = \"ellipse\") {\r\n        this.id = id;\r\n        this.literal = literal;\r\n        this.shape = shape;\r\n    }\r\n\r\n    toVisNode(): VisNode {\r\n        return {id: this.id.id, shape: this.shape, label: this.literal !== undefined ? this.literal : this.id.toString()}\r\n    }\r\n}\r\n\r\nexport class HyperEdge {\r\n    type: string;\r\n    sources: ID[];\r\n    hasTarget: boolean;\r\n\r\n    constructor(type: string, sources: ID[], hasTarget: boolean = true) {\r\n        this.type = type;\r\n        this.sources = sources;\r\n        this.hasTarget = hasTarget;\r\n    }\r\n}\r\n\r\ninterface HyperGraphProps {\r\n    nodes: Node[];\r\n    edges: HyperEdge[];\r\n    options?: {hasTarget: boolean};\r\n}\r\n\r\nconst optionsDefault = {\r\n    hasTarget: true,\r\n    layout: {\r\n        hierarchical: false\r\n    },\r\n    edges: {\r\n        color: '#000000'\r\n    },\r\n    nodes: {\r\n        margin: 10\r\n    }\r\n};\r\n\r\nexport class HyperGraph extends Component<HyperGraphProps, any> {\r\n    private readonly options: any;\r\n    private readonly hasTarget: boolean;\r\n\r\n    private events = {\r\n        select: function(event: any) {\r\n            let { nodes, edges } = event;\r\n        }\r\n    };\r\n\r\n    constructor(props: HyperGraphProps) {\r\n        super(props);\r\n        const {hasTarget, ...options} = {...optionsDefault, ...props.options};\r\n        this.hasTarget = hasTarget;\r\n        this.options = options;\r\n    }\r\n\r\n    handleResize = () => {\r\n        console.log(\"Trying rerender\");\r\n        this.forceUpdate();\r\n    };\r\n\r\n    componentDidMount() {\r\n        this.handleResize();\r\n        window.addEventListener('resize', this.handleResize)\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        window.removeEventListener('resize', this.handleResize)\r\n    }\r\n\r\n    render() {\r\n        console.log(\"rendering hyper graph\");\r\n        let maxId = Math.max(...this.props.nodes.map((value: Node) => { return value.id.id; }));\r\n\r\n        let nodes: VisNode[] = this.props.nodes.map((value, index, array) => value.toVisNode());\r\n        let edges: VisEdge[] = [];\r\n\r\n        for (let edge of this.props.edges) {\r\n            maxId += 1;\r\n            let newNode = new Node(new ID(maxId), edge.type, \"box\");\r\n            nodes.push(newNode.toVisNode());\r\n            edges = edges.concat(edge.sources.map((value: ID, index: number) => {\r\n                if (this.hasTarget && edge.hasTarget && index === 0) {\r\n                    return {to: value.id, from: newNode.id.id}\r\n                }\r\n                else if (!this.hasTarget || !edge.hasTarget) {\r\n                    return {from: value.id, to: newNode.id.id, label: \"arg \" + (index + 1)}\r\n                }\r\n                else return {from: value.id, to: newNode.id.id, label: \"arg \" + index}\r\n            }));\r\n        }\r\n\r\n        let graph = {\r\n            nodes: nodes,\r\n            edges: edges\r\n        };\r\n\r\n        console.log(\"returning new hyper graph\");\r\n        return (\r\n            <Graph graph={graph} options={this.options}  events={this.events}/>\r\n        );\r\n    }\r\n}","import React, {Component} from 'react';\r\nimport './App.css';\r\nimport {Container, Row, Col, Form, Button} from \"react-bootstrap\";\r\nimport {HyperGraph, Node, HyperEdge, ID} from './HyperGraph'\r\nimport { generate } from 'pegjs'\r\nimport Tracer from 'pegjs-backtrace'\r\n\r\ninterface AppState {\r\n  nodes: Node[];\r\n  edges: HyperEdge[];\r\n}\r\n\r\nexport class App extends Component<Readonly<{}>, AppState> {\r\n  textRef: any;\r\n\r\n  constructor(props: Readonly<{}>) {\r\n    super(props);\r\n    this.textRef = React.createRef();\r\n    this.state = {\r\n      nodes: [],\r\n      edges: []\r\n    }\r\n  }\r\n\r\n  parseText(text: string, isPattern?: boolean): any {\r\n    let parser = generate(`\r\n    expression = exp:smallerexpression \"{\" exps:expressionlist \"}\" { return {type: 'tree', root:exp, subtrees: exps} } \r\n    / smallerexpression\r\n    \r\n    smallerexpression = root:identifier _ \"(\" exps:expressionlist \")\" {\r\n      var res = {type: 'node'};\r\n      res[root['value']] = exps;\r\n      return  res;\r\n    }\r\n    / number\r\n    / identifier\r\n    / literal\r\n    \r\n    expressionlist =  _ exp:expression? exps:( _ \",\" _ expression _ )* {\r\n        if (exp === null) return [];\r\n        else if (exps.length === 0) return exp;\r\n        else return [exp].concat(exps.map(function(a){ return a[3] }))\r\n      }\r\n    \r\n    identifier = lets:([^(),\"])+ {return {type: 'identifier', value:lets.join(\"\")}}\r\n    \r\n    number = digits:[0-9]+ {return {type: 'number', value:parseInt(digits.join(\"\"), 10)}}\r\n    \r\n    literal = '\"' lets:(!'\"' .)* '\"' {return {type: 'literal', value: lets.map(x => x[1]).join(\"\")}}\r\n    \r\n    _  = [ \\\\t\\\\r\\\\n]*`);\r\n    let tracer = new Tracer(text);\r\n    let tree = null;\r\n    try {\r\n      tree = parser.parse(text, {tracer: tracer});\r\n    } catch (e) {\r\n      console.log(e);\r\n      console.log(tracer.getBacktraceString());\r\n    }\r\n    console.log(tree);\r\n    return tree;\r\n  }\r\n\r\n  static getEdges(tree: any): Array<any> {\r\n    // hypergraph(set(h,h,...))\r\n    let graphkey: string|undefined = Object.keys(tree).find(function(element: string) {\r\n      return element.toLowerCase().includes('hypergraph');\r\n    });\r\n\r\n    if (graphkey === undefined) {\r\n      throw new Error('bla');\r\n    }\r\n\r\n    console.log(graphkey);\r\n    if (Array.isArray(tree[graphkey]['Set'])) return tree[graphkey]['Set'].map((e: any) => e['HyperEdge']);\r\n    return [tree[graphkey]['Set']['HyperEdge']];\r\n  }\r\n\r\n  static extractId(hyperTermId: any) {\r\n    let label = null;\r\n    let value = -9999;\r\n    if (Object.keys(hyperTermId).includes('Explicit')) {\r\n      value = hyperTermId['Explicit']['HyperTermId']['value'];\r\n      label = 'Explicit';\r\n    } else if (Object.keys(hyperTermId).includes('Hole')) {\r\n      value = -hyperTermId['Hole']['value'];\r\n      label = 'Hole';\r\n    } else if (Object.keys(hyperTermId).includes('Ignore')){\r\n      label = 'Ignore';\r\n    } else if (Object.keys(hyperTermId).includes('Repetition')) {\r\n      value = hyperTermId['Repetition'][1]['value'];\r\n      label = 'Repetition';\r\n    } else if (Object.keys(hyperTermId).includes('Stream')) {\r\n      value = hyperTermId['Repetition'][1]['value'];\r\n      label = 'Repetition';\r\n    } else return new ID(hyperTermId['HyperTermId']['value']);\r\n\r\n    return new ID(value, label + '(' + value + ')');\r\n  }\r\n\r\n  static extractIdentifier(hyperTermIdentifier: any): string {\r\n    if (Object.keys(hyperTermIdentifier).includes('Explicit')) {\r\n      var literal = hyperTermIdentifier['Explicit']['HyperTermIdentifier']['Identifier'][0];\r\n      return literal['value'];\r\n    } else if (Object.keys(hyperTermIdentifier).includes('Hole')) {\r\n      return \"Hole(\" + hyperTermIdentifier['Hole']['value'] + \")\";\r\n    } else if (Object.keys(hyperTermIdentifier).includes('Ignore')) {\r\n      return  'Ignore';\r\n    } else return hyperTermIdentifier['HyperTermIdentifier']['Identifier'][0]['value'];\r\n  }\r\n\r\n  static parseEdge(edge: any) {\r\n    let eType = App.extractIdentifier(edge[1]);\r\n    let target = [App.extractId(edge[0])];\r\n    let sources = edge[2]['List'];\r\n    if (sources === undefined) sources = [];\r\n    else if (Array.isArray(sources))\r\n      sources = sources.map(App.extractId);\r\n    else sources = [App.extractId(sources)];\r\n    if (eType === \"type\") return new HyperEdge(eType, sources, false);\r\n    return new HyperEdge(eType, target.concat(sources));\r\n  }\r\n\r\n  handleClick(event: React.MouseEvent<HTMLButtonElement, MouseEvent>) {\r\n    let text = this.textRef.current.value;\r\n    if (typeof text === 'string') {\r\n      let tree = this.parseText(text);\r\n      let edges = App.getEdges(tree).map(e => App.parseEdge(e));\r\n      let nodes = new Map<number, Node>(edges.flatMap(function (e: HyperEdge) {\r\n        console.log(e.sources);\r\n        return e.sources.map(f => [f.id, new Node(f)])\r\n      }));\r\n      this.setState({nodes: Array.from(nodes.values()), edges: edges})\r\n    }\r\n  }\r\n\r\n  handleResize = () => {\r\n    console.log(\"Trying rerender\");\r\n    this.forceUpdate();\r\n  };\r\n\r\n  componentDidMount() {\r\n    this.handleResize();\r\n    window.addEventListener('resize', this.handleResize)\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.removeEventListener('resize', this.handleResize)\r\n  }\r\n\r\n  render() {\r\n    console.log(\"rendering app\");\r\n    return (\r\n    <Container style={{height: '100vh', 'minHeight': '100vh'}}>\r\n      <Row>\r\n        <Col><Button onClick={this.handleClick.bind(this)}>Draw Graph!</Button>\r\n        <Form.Control ref={this.textRef} style={{width: '75vh'}} type=\"text\" placeholder=\"Enter hyper graph text\"/></Col>\r\n      </Row>\r\n      <Row style={{height: '100%'}}>\r\n        <HyperGraph\r\n            edges={this.state.edges}\r\n            nodes={this.state.nodes}/>\r\n      </Row>\r\n    </Container>);\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}